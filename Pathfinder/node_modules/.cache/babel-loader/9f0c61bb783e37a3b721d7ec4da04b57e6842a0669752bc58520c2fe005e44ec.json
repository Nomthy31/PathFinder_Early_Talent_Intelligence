{"ast":null,"code":"import { __rest } from \"tslib\";\nimport { base64UrlToUint8Array, bytesToBase64URL } from './base64url';\nimport { AuthError, AuthUnknownError, isAuthError } from './errors';\nimport { isBrowser } from './helpers';\nimport { identifyAuthenticationError, identifyRegistrationError, isWebAuthnError, WebAuthnError, WebAuthnUnknownError } from './webauthn.errors';\nexport { WebAuthnError, isWebAuthnError, identifyRegistrationError, identifyAuthenticationError };\n/**\r\n * WebAuthn abort service to manage ceremony cancellation.\r\n * Ensures only one WebAuthn ceremony is active at a time to prevent \"operation already in progress\" errors.\r\n *\r\n * @experimental This class is experimental and may change in future releases\r\n * @see {@link https://w3c.github.io/webauthn/#sctn-automation-webdriver-capability W3C WebAuthn Spec - Aborting Ceremonies}\r\n */\nexport class WebAuthnAbortService {\n  /**\r\n   * Create an abort signal for a new WebAuthn operation.\r\n   * Automatically cancels any existing operation.\r\n   *\r\n   * @returns {AbortSignal} Signal to pass to navigator.credentials.create() or .get()\r\n   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal MDN - AbortSignal}\r\n   */\n  createNewAbortSignal() {\n    // Abort any existing calls to navigator.credentials.create() or navigator.credentials.get()\n    if (this.controller) {\n      const abortError = new Error('Cancelling existing WebAuthn API call for new one');\n      abortError.name = 'AbortError';\n      this.controller.abort(abortError);\n    }\n    const newController = new AbortController();\n    this.controller = newController;\n    return newController.signal;\n  }\n  /**\r\n   * Manually cancel the current WebAuthn operation.\r\n   * Useful for cleaning up when user cancels or navigates away.\r\n   *\r\n   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/AbortController/abort MDN - AbortController.abort}\r\n   */\n  cancelCeremony() {\n    if (this.controller) {\n      const abortError = new Error('Manually cancelling existing WebAuthn API call');\n      abortError.name = 'AbortError';\n      this.controller.abort(abortError);\n      this.controller = undefined;\n    }\n  }\n}\n/**\r\n * Singleton instance to ensure only one WebAuthn ceremony is active at a time.\r\n * This prevents \"operation already in progress\" errors when retrying WebAuthn operations.\r\n *\r\n * @experimental This instance is experimental and may change in future releases\r\n */\nexport const webAuthnAbortService = new WebAuthnAbortService();\n/**\r\n * Convert base64url encoded strings in WebAuthn credential creation options to ArrayBuffers\r\n * as required by the WebAuthn browser API.\r\n * Supports both native WebAuthn Level 3 parseCreationOptionsFromJSON and manual fallback.\r\n *\r\n * @param {ServerCredentialCreationOptions} options - JSON options from server with base64url encoded fields\r\n * @returns {PublicKeyCredentialCreationOptionsFuture} Options ready for navigator.credentials.create()\r\n * @see {@link https://w3c.github.io/webauthn/#sctn-parseCreationOptionsFromJSON W3C WebAuthn Spec - parseCreationOptionsFromJSON}\r\n */\nexport function deserializeCredentialCreationOptions(options) {\n  if (!options) {\n    throw new Error('Credential creation options are required');\n  }\n  // Check if the native parseCreationOptionsFromJSON method is available\n  if (typeof PublicKeyCredential !== 'undefined' && 'parseCreationOptionsFromJSON' in PublicKeyCredential && typeof PublicKeyCredential.parseCreationOptionsFromJSON === 'function') {\n    // Use the native WebAuthn Level 3 method\n    return PublicKeyCredential.parseCreationOptionsFromJSON(/** we assert the options here as typescript still doesn't know about future webauthn types */\n    options);\n  }\n  // Fallback to manual parsing for browsers that don't support the native method\n  // Destructure to separate fields that need transformation\n  const {\n      challenge: challengeStr,\n      user: userOpts,\n      excludeCredentials\n    } = options,\n    restOptions = __rest(options\n    // Convert challenge from base64url to ArrayBuffer\n    , [\"challenge\", \"user\", \"excludeCredentials\"]);\n  // Convert challenge from base64url to ArrayBuffer\n  const challenge = base64UrlToUint8Array(challengeStr).buffer;\n  // Convert user.id from base64url to ArrayBuffer\n  const user = Object.assign(Object.assign({}, userOpts), {\n    id: base64UrlToUint8Array(userOpts.id).buffer\n  });\n  // Build the result object\n  const result = Object.assign(Object.assign({}, restOptions), {\n    challenge,\n    user\n  });\n  // Only add excludeCredentials if it exists\n  if (excludeCredentials && excludeCredentials.length > 0) {\n    result.excludeCredentials = new Array(excludeCredentials.length);\n    for (let i = 0; i < excludeCredentials.length; i++) {\n      const cred = excludeCredentials[i];\n      result.excludeCredentials[i] = Object.assign(Object.assign({}, cred), {\n        id: base64UrlToUint8Array(cred.id).buffer,\n        type: cred.type || 'public-key',\n        // Cast transports to handle future transport types like \"cable\"\n        transports: cred.transports\n      });\n    }\n  }\n  return result;\n}\n/**\r\n * Convert base64url encoded strings in WebAuthn credential request options to ArrayBuffers\r\n * as required by the WebAuthn browser API.\r\n * Supports both native WebAuthn Level 3 parseRequestOptionsFromJSON and manual fallback.\r\n *\r\n * @param {ServerCredentialRequestOptions} options - JSON options from server with base64url encoded fields\r\n * @returns {PublicKeyCredentialRequestOptionsFuture} Options ready for navigator.credentials.get()\r\n * @see {@link https://w3c.github.io/webauthn/#sctn-parseRequestOptionsFromJSON W3C WebAuthn Spec - parseRequestOptionsFromJSON}\r\n */\nexport function deserializeCredentialRequestOptions(options) {\n  if (!options) {\n    throw new Error('Credential request options are required');\n  }\n  // Check if the native parseRequestOptionsFromJSON method is available\n  if (typeof PublicKeyCredential !== 'undefined' && 'parseRequestOptionsFromJSON' in PublicKeyCredential && typeof PublicKeyCredential.parseRequestOptionsFromJSON === 'function') {\n    // Use the native WebAuthn Level 3 method\n    return PublicKeyCredential.parseRequestOptionsFromJSON(options);\n  }\n  // Fallback to manual parsing for browsers that don't support the native method\n  // Destructure to separate fields that need transformation\n  const {\n      challenge: challengeStr,\n      allowCredentials\n    } = options,\n    restOptions = __rest(options\n    // Convert challenge from base64url to ArrayBuffer\n    , [\"challenge\", \"allowCredentials\"]);\n  // Convert challenge from base64url to ArrayBuffer\n  const challenge = base64UrlToUint8Array(challengeStr).buffer;\n  // Build the result object\n  const result = Object.assign(Object.assign({}, restOptions), {\n    challenge\n  });\n  // Only add allowCredentials if it exists\n  if (allowCredentials && allowCredentials.length > 0) {\n    result.allowCredentials = new Array(allowCredentials.length);\n    for (let i = 0; i < allowCredentials.length; i++) {\n      const cred = allowCredentials[i];\n      result.allowCredentials[i] = Object.assign(Object.assign({}, cred), {\n        id: base64UrlToUint8Array(cred.id).buffer,\n        type: cred.type || 'public-key',\n        // Cast transports to handle future transport types like \"cable\"\n        transports: cred.transports\n      });\n    }\n  }\n  return result;\n}\n/**\r\n * Convert a registration/enrollment credential response to server format.\r\n * Serializes binary fields to base64url for JSON transmission.\r\n * Supports both native WebAuthn Level 3 toJSON and manual fallback.\r\n *\r\n * @param {RegistrationCredential} credential - Credential from navigator.credentials.create()\r\n * @returns {RegistrationResponseJSON} JSON-serializable credential for server\r\n * @see {@link https://w3c.github.io/webauthn/#dom-publickeycredential-tojson W3C WebAuthn Spec - toJSON}\r\n */\nexport function serializeCredentialCreationResponse(credential) {\n  var _a;\n  // Check if the credential instance has the toJSON method\n  if ('toJSON' in credential && typeof credential.toJSON === 'function') {\n    // Use the native WebAuthn Level 3 method\n    return credential.toJSON();\n  }\n  const credentialWithAttachment = credential;\n  return {\n    id: credential.id,\n    rawId: credential.id,\n    response: {\n      attestationObject: bytesToBase64URL(new Uint8Array(credential.response.attestationObject)),\n      clientDataJSON: bytesToBase64URL(new Uint8Array(credential.response.clientDataJSON))\n    },\n    type: 'public-key',\n    clientExtensionResults: credential.getClientExtensionResults(),\n    // Convert null to undefined and cast to AuthenticatorAttachment type\n    authenticatorAttachment: (_a = credentialWithAttachment.authenticatorAttachment) !== null && _a !== void 0 ? _a : undefined\n  };\n}\n/**\r\n * Convert an authentication/verification credential response to server format.\r\n * Serializes binary fields to base64url for JSON transmission.\r\n * Supports both native WebAuthn Level 3 toJSON and manual fallback.\r\n *\r\n * @param {AuthenticationCredential} credential - Credential from navigator.credentials.get()\r\n * @returns {AuthenticationResponseJSON} JSON-serializable credential for server\r\n * @see {@link https://w3c.github.io/webauthn/#dom-publickeycredential-tojson W3C WebAuthn Spec - toJSON}\r\n */\nexport function serializeCredentialRequestResponse(credential) {\n  var _a;\n  // Check if the credential instance has the toJSON method\n  if ('toJSON' in credential && typeof credential.toJSON === 'function') {\n    // Use the native WebAuthn Level 3 method\n    return credential.toJSON();\n  }\n  // Fallback to manual conversion for browsers that don't support toJSON\n  // Access authenticatorAttachment via type assertion to handle TypeScript version differences\n  // @simplewebauthn/types includes this property but base TypeScript 4.7.4 doesn't\n  const credentialWithAttachment = credential;\n  const clientExtensionResults = credential.getClientExtensionResults();\n  const assertionResponse = credential.response;\n  return {\n    id: credential.id,\n    rawId: credential.id,\n    // W3C spec expects rawId to match id for JSON format\n    response: {\n      authenticatorData: bytesToBase64URL(new Uint8Array(assertionResponse.authenticatorData)),\n      clientDataJSON: bytesToBase64URL(new Uint8Array(assertionResponse.clientDataJSON)),\n      signature: bytesToBase64URL(new Uint8Array(assertionResponse.signature)),\n      userHandle: assertionResponse.userHandle ? bytesToBase64URL(new Uint8Array(assertionResponse.userHandle)) : undefined\n    },\n    type: 'public-key',\n    clientExtensionResults,\n    // Convert null to undefined and cast to AuthenticatorAttachment type\n    authenticatorAttachment: (_a = credentialWithAttachment.authenticatorAttachment) !== null && _a !== void 0 ? _a : undefined\n  };\n}\n/**\r\n * A simple test to determine if a hostname is a properly-formatted domain name.\r\n * Considers localhost valid for development environments.\r\n *\r\n * A \"valid domain\" is defined here: https://url.spec.whatwg.org/#valid-domain\r\n *\r\n * Regex sourced from here:\r\n * https://www.oreilly.com/library/view/regular-expressions-cookbook/9781449327453/ch08s15.html\r\n *\r\n * @param {string} hostname - The hostname to validate\r\n * @returns {boolean} True if valid domain or localhost\r\n * @see {@link https://url.spec.whatwg.org/#valid-domain WHATWG URL Spec - Valid Domain}\r\n */\nexport function isValidDomain(hostname) {\n  return (\n    // Consider localhost valid as well since it's okay wrt Secure Contexts\n    hostname === 'localhost' || /^([a-z0-9]+(-[a-z0-9]+)*\\.)+[a-z]{2,}$/i.test(hostname)\n  );\n}\n/**\r\n * Determine if the browser is capable of WebAuthn.\r\n * Checks for necessary Web APIs: PublicKeyCredential and Credential Management.\r\n *\r\n * @returns {boolean} True if browser supports WebAuthn\r\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/PublicKeyCredential#browser_compatibility MDN - PublicKeyCredential Browser Compatibility}\r\n */\nfunction browserSupportsWebAuthn() {\n  var _a, _b;\n  return !!(isBrowser() && 'PublicKeyCredential' in window && window.PublicKeyCredential && 'credentials' in navigator && typeof ((_a = navigator === null || navigator === void 0 ? void 0 : navigator.credentials) === null || _a === void 0 ? void 0 : _a.create) === 'function' && typeof ((_b = navigator === null || navigator === void 0 ? void 0 : navigator.credentials) === null || _b === void 0 ? void 0 : _b.get) === 'function');\n}\n/**\r\n * Create a WebAuthn credential using the browser's credentials API.\r\n * Wraps navigator.credentials.create() with error handling.\r\n *\r\n * @param {CredentialCreationOptions} options - Options including publicKey parameters\r\n * @returns {Promise<RequestResult<RegistrationCredential, WebAuthnError>>} Created credential or error\r\n * @see {@link https://w3c.github.io/webauthn/#sctn-createCredential W3C WebAuthn Spec - Create Credential}\r\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/CredentialsContainer/create MDN - credentials.create}\r\n */\nexport async function createCredential(options) {\n  try {\n    const response = await navigator.credentials.create(/** we assert the type here until typescript types are updated */\n    options);\n    if (!response) {\n      return {\n        data: null,\n        error: new WebAuthnUnknownError('Empty credential response', response)\n      };\n    }\n    if (!(response instanceof PublicKeyCredential)) {\n      return {\n        data: null,\n        error: new WebAuthnUnknownError('Browser returned unexpected credential type', response)\n      };\n    }\n    return {\n      data: response,\n      error: null\n    };\n  } catch (err) {\n    return {\n      data: null,\n      error: identifyRegistrationError({\n        error: err,\n        options\n      })\n    };\n  }\n}\n/**\r\n * Get a WebAuthn credential using the browser's credentials API.\r\n * Wraps navigator.credentials.get() with error handling.\r\n *\r\n * @param {CredentialRequestOptions} options - Options including publicKey parameters\r\n * @returns {Promise<RequestResult<AuthenticationCredential, WebAuthnError>>} Retrieved credential or error\r\n * @see {@link https://w3c.github.io/webauthn/#sctn-getAssertion W3C WebAuthn Spec - Get Assertion}\r\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/CredentialsContainer/get MDN - credentials.get}\r\n */\nexport async function getCredential(options) {\n  try {\n    const response = await navigator.credentials.get(/** we assert the type here until typescript types are updated */\n    options);\n    if (!response) {\n      return {\n        data: null,\n        error: new WebAuthnUnknownError('Empty credential response', response)\n      };\n    }\n    if (!(response instanceof PublicKeyCredential)) {\n      return {\n        data: null,\n        error: new WebAuthnUnknownError('Browser returned unexpected credential type', response)\n      };\n    }\n    return {\n      data: response,\n      error: null\n    };\n  } catch (err) {\n    return {\n      data: null,\n      error: identifyAuthenticationError({\n        error: err,\n        options\n      })\n    };\n  }\n}\nexport const DEFAULT_CREATION_OPTIONS = {\n  hints: ['security-key'],\n  authenticatorSelection: {\n    authenticatorAttachment: 'cross-platform',\n    requireResidentKey: false,\n    /** set to preferred because older yubikeys don't have PIN/Biometric */\n    userVerification: 'preferred',\n    residentKey: 'discouraged'\n  },\n  attestation: 'none'\n};\nexport const DEFAULT_REQUEST_OPTIONS = {\n  /** set to preferred because older yubikeys don't have PIN/Biometric */\n  userVerification: 'preferred',\n  hints: ['security-key']\n};\nfunction deepMerge(...sources) {\n  const isObject = val => val !== null && typeof val === 'object' && !Array.isArray(val);\n  const isArrayBufferLike = val => val instanceof ArrayBuffer || ArrayBuffer.isView(val);\n  const result = {};\n  for (const source of sources) {\n    if (!source) continue;\n    for (const key in source) {\n      const value = source[key];\n      if (value === undefined) continue;\n      if (Array.isArray(value)) {\n        // preserve array reference, including unions like AuthenticatorTransport[]\n        result[key] = value;\n      } else if (isArrayBufferLike(value)) {\n        result[key] = value;\n      } else if (isObject(value)) {\n        const existing = result[key];\n        if (isObject(existing)) {\n          result[key] = deepMerge(existing, value);\n        } else {\n          result[key] = deepMerge(value);\n        }\n      } else {\n        result[key] = value;\n      }\n    }\n  }\n  return result;\n}\n/**\r\n * Merges WebAuthn credential creation options with overrides.\r\n * Sets sensible defaults for authenticator selection and extensions.\r\n *\r\n * @param {PublicKeyCredentialCreationOptionsFuture} baseOptions - The base options from the server\r\n * @param {PublicKeyCredentialCreationOptionsFuture} overrides - Optional overrides to apply\r\n * @param {string} friendlyName - Optional friendly name for the credential\r\n * @returns {PublicKeyCredentialCreationOptionsFuture} Merged credential creation options\r\n * @see {@link https://w3c.github.io/webauthn/#dictdef-authenticatorselectioncriteria W3C WebAuthn Spec - AuthenticatorSelectionCriteria}\r\n */\nexport function mergeCredentialCreationOptions(baseOptions, overrides) {\n  return deepMerge(DEFAULT_CREATION_OPTIONS, baseOptions, overrides || {});\n}\n/**\r\n * Merges WebAuthn credential request options with overrides.\r\n * Sets sensible defaults for user verification and hints.\r\n *\r\n * @param {PublicKeyCredentialRequestOptionsFuture} baseOptions - The base options from the server\r\n * @param {PublicKeyCredentialRequestOptionsFuture} overrides - Optional overrides to apply\r\n * @returns {PublicKeyCredentialRequestOptionsFuture} Merged credential request options\r\n * @see {@link https://w3c.github.io/webauthn/#dictdef-publickeycredentialrequestoptions W3C WebAuthn Spec - PublicKeyCredentialRequestOptions}\r\n */\nexport function mergeCredentialRequestOptions(baseOptions, overrides) {\n  return deepMerge(DEFAULT_REQUEST_OPTIONS, baseOptions, overrides || {});\n}\n/**\r\n * WebAuthn API wrapper for Supabase Auth.\r\n * Provides methods for enrolling, challenging, verifying, authenticating, and registering WebAuthn credentials.\r\n *\r\n * @experimental This API is experimental and may change in future releases\r\n * @see {@link https://w3c.github.io/webauthn/ W3C WebAuthn Specification}\r\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/Web_Authentication_API MDN - Web Authentication API}\r\n */\nexport class WebAuthnApi {\n  constructor(client) {\n    this.client = client;\n    // Bind all methods so they can be destructured\n    this.enroll = this._enroll.bind(this);\n    this.challenge = this._challenge.bind(this);\n    this.verify = this._verify.bind(this);\n    this.authenticate = this._authenticate.bind(this);\n    this.register = this._register.bind(this);\n  }\n  /**\r\n   * Enroll a new WebAuthn factor.\r\n   * Creates an unverified WebAuthn factor that must be verified with a credential.\r\n   *\r\n   * @experimental This method is experimental and may change in future releases\r\n   * @param {Omit<MFAEnrollWebauthnParams, 'factorType'>} params - Enrollment parameters (friendlyName required)\r\n   * @returns {Promise<AuthMFAEnrollWebauthnResponse>} Enrolled factor details or error\r\n   * @see {@link https://w3c.github.io/webauthn/#sctn-registering-a-new-credential W3C WebAuthn Spec - Registering a New Credential}\r\n   */\n  async _enroll(params) {\n    return this.client.mfa.enroll(Object.assign(Object.assign({}, params), {\n      factorType: 'webauthn'\n    }));\n  }\n  /**\r\n   * Challenge for WebAuthn credential creation or authentication.\r\n   * Combines server challenge with browser credential operations.\r\n   * Handles both registration (create) and authentication (request) flows.\r\n   *\r\n   * @experimental This method is experimental and may change in future releases\r\n   * @param {MFAChallengeWebauthnParams & { friendlyName?: string; signal?: AbortSignal }} params - Challenge parameters including factorId\r\n   * @param {Object} overrides - Allows you to override the parameters passed to navigator.credentials\r\n   * @param {PublicKeyCredentialCreationOptionsFuture} overrides.create - Override options for credential creation\r\n   * @param {PublicKeyCredentialRequestOptionsFuture} overrides.request - Override options for credential request\r\n   * @returns {Promise<RequestResult>} Challenge response with credential or error\r\n   * @see {@link https://w3c.github.io/webauthn/#sctn-credential-creation W3C WebAuthn Spec - Credential Creation}\r\n   * @see {@link https://w3c.github.io/webauthn/#sctn-verifying-assertion W3C WebAuthn Spec - Verifying Assertion}\r\n   */\n  async _challenge({\n    factorId,\n    webauthn,\n    friendlyName,\n    signal\n  }, overrides) {\n    try {\n      // Get challenge from server using the client's MFA methods\n      const {\n        data: challengeResponse,\n        error: challengeError\n      } = await this.client.mfa.challenge({\n        factorId,\n        webauthn\n      });\n      if (!challengeResponse) {\n        return {\n          data: null,\n          error: challengeError\n        };\n      }\n      const abortSignal = signal !== null && signal !== void 0 ? signal : webAuthnAbortService.createNewAbortSignal();\n      /** webauthn will fail if either of the name/displayname are blank */\n      if (challengeResponse.webauthn.type === 'create') {\n        const {\n          user\n        } = challengeResponse.webauthn.credential_options.publicKey;\n        if (!user.name) {\n          user.name = `${user.id}:${friendlyName}`;\n        }\n        if (!user.displayName) {\n          user.displayName = user.name;\n        }\n      }\n      switch (challengeResponse.webauthn.type) {\n        case 'create':\n          {\n            const options = mergeCredentialCreationOptions(challengeResponse.webauthn.credential_options.publicKey, overrides === null || overrides === void 0 ? void 0 : overrides.create);\n            const {\n              data,\n              error\n            } = await createCredential({\n              publicKey: options,\n              signal: abortSignal\n            });\n            if (data) {\n              return {\n                data: {\n                  factorId,\n                  challengeId: challengeResponse.id,\n                  webauthn: {\n                    type: challengeResponse.webauthn.type,\n                    credential_response: data\n                  }\n                },\n                error: null\n              };\n            }\n            return {\n              data: null,\n              error\n            };\n          }\n        case 'request':\n          {\n            const options = mergeCredentialRequestOptions(challengeResponse.webauthn.credential_options.publicKey, overrides === null || overrides === void 0 ? void 0 : overrides.request);\n            const {\n              data,\n              error\n            } = await getCredential(Object.assign(Object.assign({}, challengeResponse.webauthn.credential_options), {\n              publicKey: options,\n              signal: abortSignal\n            }));\n            if (data) {\n              return {\n                data: {\n                  factorId,\n                  challengeId: challengeResponse.id,\n                  webauthn: {\n                    type: challengeResponse.webauthn.type,\n                    credential_response: data\n                  }\n                },\n                error: null\n              };\n            }\n            return {\n              data: null,\n              error\n            };\n          }\n      }\n    } catch (error) {\n      if (isAuthError(error)) {\n        return {\n          data: null,\n          error\n        };\n      }\n      return {\n        data: null,\n        error: new AuthUnknownError('Unexpected error in challenge', error)\n      };\n    }\n  }\n  /**\r\n   * Verify a WebAuthn credential with the server.\r\n   * Completes the WebAuthn ceremony by sending the credential to the server for verification.\r\n   *\r\n   * @experimental This method is experimental and may change in future releases\r\n   * @param {Object} params - Verification parameters\r\n   * @param {string} params.challengeId - ID of the challenge being verified\r\n   * @param {string} params.factorId - ID of the WebAuthn factor\r\n   * @param {MFAVerifyWebauthnParams<T>['webauthn']} params.webauthn - WebAuthn credential response\r\n   * @returns {Promise<AuthMFAVerifyResponse>} Verification result with session or error\r\n   * @see {@link https://w3c.github.io/webauthn/#sctn-verifying-assertion W3C WebAuthn Spec - Verifying an Authentication Assertion}\r\n   * */\n  async _verify({\n    challengeId,\n    factorId,\n    webauthn\n  }) {\n    return this.client.mfa.verify({\n      factorId,\n      challengeId,\n      webauthn: webauthn\n    });\n  }\n  /**\r\n   * Complete WebAuthn authentication flow.\r\n   * Performs challenge and verification in a single operation for existing credentials.\r\n   *\r\n   * @experimental This method is experimental and may change in future releases\r\n   * @param {Object} params - Authentication parameters\r\n   * @param {string} params.factorId - ID of the WebAuthn factor to authenticate with\r\n   * @param {Object} params.webauthn - WebAuthn configuration\r\n   * @param {string} params.webauthn.rpId - Relying Party ID (defaults to current hostname)\r\n   * @param {string[]} params.webauthn.rpOrigins - Allowed origins (defaults to current origin)\r\n   * @param {AbortSignal} params.webauthn.signal - Optional abort signal\r\n   * @param {PublicKeyCredentialRequestOptionsFuture} overrides - Override options for navigator.credentials.get\r\n   * @returns {Promise<RequestResult<AuthMFAVerifyResponseData, WebAuthnError | AuthError>>} Authentication result\r\n   * @see {@link https://w3c.github.io/webauthn/#sctn-authentication W3C WebAuthn Spec - Authentication Ceremony}\r\n   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/PublicKeyCredentialRequestOptions MDN - PublicKeyCredentialRequestOptions}\r\n   */\n  async _authenticate({\n    factorId,\n    webauthn: {\n      rpId = typeof window !== 'undefined' ? window.location.hostname : undefined,\n      rpOrigins = typeof window !== 'undefined' ? [window.location.origin] : undefined,\n      signal\n    }\n  }, overrides) {\n    if (!rpId) {\n      return {\n        data: null,\n        error: new AuthError('rpId is required for WebAuthn authentication')\n      };\n    }\n    try {\n      if (!browserSupportsWebAuthn()) {\n        return {\n          data: null,\n          error: new AuthUnknownError('Browser does not support WebAuthn', null)\n        };\n      }\n      // Get challenge and credential\n      const {\n        data: challengeResponse,\n        error: challengeError\n      } = await this.challenge({\n        factorId,\n        webauthn: {\n          rpId,\n          rpOrigins\n        },\n        signal\n      }, {\n        request: overrides\n      });\n      if (!challengeResponse) {\n        return {\n          data: null,\n          error: challengeError\n        };\n      }\n      const {\n        webauthn\n      } = challengeResponse;\n      // Verify credential\n      return this._verify({\n        factorId,\n        challengeId: challengeResponse.challengeId,\n        webauthn: {\n          type: webauthn.type,\n          rpId,\n          rpOrigins,\n          credential_response: webauthn.credential_response\n        }\n      });\n    } catch (error) {\n      if (isAuthError(error)) {\n        return {\n          data: null,\n          error\n        };\n      }\n      return {\n        data: null,\n        error: new AuthUnknownError('Unexpected error in authenticate', error)\n      };\n    }\n  }\n  /**\r\n   * Complete WebAuthn registration flow.\r\n   * Performs enrollment, challenge, and verification in a single operation for new credentials.\r\n   *\r\n   * @experimental This method is experimental and may change in future releases\r\n   * @param {Object} params - Registration parameters\r\n   * @param {string} params.friendlyName - User-friendly name for the credential\r\n   * @param {string} params.rpId - Relying Party ID (defaults to current hostname)\r\n   * @param {string[]} params.rpOrigins - Allowed origins (defaults to current origin)\r\n   * @param {AbortSignal} params.signal - Optional abort signal\r\n   * @param {PublicKeyCredentialCreationOptionsFuture} overrides - Override options for navigator.credentials.create\r\n   * @returns {Promise<RequestResult<AuthMFAVerifyResponseData, WebAuthnError | AuthError>>} Registration result\r\n   * @see {@link https://w3c.github.io/webauthn/#sctn-registering-a-new-credential W3C WebAuthn Spec - Registration Ceremony}\r\n   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/PublicKeyCredentialCreationOptions MDN - PublicKeyCredentialCreationOptions}\r\n   */\n  async _register({\n    friendlyName,\n    rpId = typeof window !== 'undefined' ? window.location.hostname : undefined,\n    rpOrigins = typeof window !== 'undefined' ? [window.location.origin] : undefined,\n    signal\n  }, overrides) {\n    if (!rpId) {\n      return {\n        data: null,\n        error: new AuthError('rpId is required for WebAuthn registration')\n      };\n    }\n    try {\n      if (!browserSupportsWebAuthn()) {\n        return {\n          data: null,\n          error: new AuthUnknownError('Browser does not support WebAuthn', null)\n        };\n      }\n      // Enroll factor\n      const {\n        data: factor,\n        error: enrollError\n      } = await this._enroll({\n        friendlyName\n      });\n      if (!factor) {\n        await this.client.mfa.listFactors().then(factors => {\n          var _a;\n          return (_a = factors.data) === null || _a === void 0 ? void 0 : _a.all.find(v => v.factor_type === 'webauthn' && v.friendly_name === friendlyName && v.status !== 'unverified');\n        }).then(factor => factor ? this.client.mfa.unenroll({\n          factorId: factor === null || factor === void 0 ? void 0 : factor.id\n        }) : void 0);\n        return {\n          data: null,\n          error: enrollError\n        };\n      }\n      // Get challenge and create credential\n      const {\n        data: challengeResponse,\n        error: challengeError\n      } = await this._challenge({\n        factorId: factor.id,\n        friendlyName: factor.friendly_name,\n        webauthn: {\n          rpId,\n          rpOrigins\n        },\n        signal\n      }, {\n        create: overrides\n      });\n      if (!challengeResponse) {\n        return {\n          data: null,\n          error: challengeError\n        };\n      }\n      return this._verify({\n        factorId: factor.id,\n        challengeId: challengeResponse.challengeId,\n        webauthn: {\n          rpId,\n          rpOrigins,\n          type: challengeResponse.webauthn.type,\n          credential_response: challengeResponse.webauthn.credential_response\n        }\n      });\n    } catch (error) {\n      if (isAuthError(error)) {\n        return {\n          data: null,\n          error\n        };\n      }\n      return {\n        data: null,\n        error: new AuthUnknownError('Unexpected error in register', error)\n      };\n    }\n  }\n}","map":{"version":3,"names":["base64UrlToUint8Array","bytesToBase64URL","AuthError","AuthUnknownError","isAuthError","isBrowser","identifyAuthenticationError","identifyRegistrationError","isWebAuthnError","WebAuthnError","WebAuthnUnknownError","WebAuthnAbortService","createNewAbortSignal","controller","abortError","Error","name","abort","newController","AbortController","signal","cancelCeremony","undefined","webAuthnAbortService","deserializeCredentialCreationOptions","options","PublicKeyCredential","parseCreationOptionsFromJSON","challenge","challengeStr","user","userOpts","excludeCredentials","restOptions","__rest","buffer","Object","assign","id","result","length","Array","i","cred","type","transports","deserializeCredentialRequestOptions","parseRequestOptionsFromJSON","allowCredentials","serializeCredentialCreationResponse","credential","toJSON","credentialWithAttachment","rawId","response","attestationObject","Uint8Array","clientDataJSON","clientExtensionResults","getClientExtensionResults","authenticatorAttachment","_a","serializeCredentialRequestResponse","assertionResponse","authenticatorData","signature","userHandle","isValidDomain","hostname","test","browserSupportsWebAuthn","window","navigator","credentials","create","_b","get","createCredential","data","error","err","getCredential","DEFAULT_CREATION_OPTIONS","hints","authenticatorSelection","requireResidentKey","userVerification","residentKey","attestation","DEFAULT_REQUEST_OPTIONS","deepMerge","sources","isObject","val","isArray","isArrayBufferLike","ArrayBuffer","isView","source","key","value","existing","mergeCredentialCreationOptions","baseOptions","overrides","mergeCredentialRequestOptions","WebAuthnApi","constructor","client","enroll","_enroll","bind","_challenge","verify","_verify","authenticate","_authenticate","register","_register","params","mfa","factorType","factorId","webauthn","friendlyName","challengeResponse","challengeError","abortSignal","credential_options","publicKey","displayName","challengeId","credential_response","request","rpId","location","rpOrigins","origin","factor","enrollError","listFactors","then","factors","all","find","v","factor_type","friendly_name","status","unenroll"],"sources":["C:\\Users\\thato\\OneDrive\\Desktop\\Hack\\PathFinder_Early_Talent_Intelligence\\Pathfinder\\node_modules\\@supabase\\auth-js\\src\\lib\\webauthn.ts"],"sourcesContent":["import GoTrueClient from '../GoTrueClient'\r\nimport { base64UrlToUint8Array, bytesToBase64URL } from './base64url'\r\nimport { AuthError, AuthUnknownError, isAuthError } from './errors'\r\nimport {\r\n  AuthMFAEnrollWebauthnResponse,\r\n  AuthMFAVerifyResponse,\r\n  AuthMFAVerifyResponseData,\r\n  MFAChallengeWebauthnParams,\r\n  MFAEnrollWebauthnParams,\r\n  MFAVerifyWebauthnParamFields,\r\n  MFAVerifyWebauthnParams,\r\n  RequestResult,\r\n  StrictOmit,\r\n} from './types'\r\nimport { isBrowser } from './helpers'\r\nimport type {\r\n  AuthenticationCredential,\r\n  AuthenticationResponseJSON,\r\n  AuthenticatorAttachment,\r\n  PublicKeyCredentialCreationOptionsFuture,\r\n  PublicKeyCredentialCreationOptionsJSON,\r\n  PublicKeyCredentialFuture,\r\n  PublicKeyCredentialRequestOptionsFuture,\r\n  PublicKeyCredentialRequestOptionsJSON,\r\n  RegistrationCredential,\r\n  RegistrationResponseJSON,\r\n} from './webauthn.dom'\r\n\r\nimport {\r\n  identifyAuthenticationError,\r\n  identifyRegistrationError,\r\n  isWebAuthnError,\r\n  WebAuthnError,\r\n  WebAuthnUnknownError,\r\n} from './webauthn.errors'\r\n\r\nexport { WebAuthnError, isWebAuthnError, identifyRegistrationError, identifyAuthenticationError }\r\n// Re-export the JSON types for use in other files\r\nexport type { RegistrationResponseJSON, AuthenticationResponseJSON }\r\n\r\n/**\r\n * WebAuthn abort service to manage ceremony cancellation.\r\n * Ensures only one WebAuthn ceremony is active at a time to prevent \"operation already in progress\" errors.\r\n *\r\n * @experimental This class is experimental and may change in future releases\r\n * @see {@link https://w3c.github.io/webauthn/#sctn-automation-webdriver-capability W3C WebAuthn Spec - Aborting Ceremonies}\r\n */\r\nexport class WebAuthnAbortService {\r\n  private controller: AbortController | undefined\r\n\r\n  /**\r\n   * Create an abort signal for a new WebAuthn operation.\r\n   * Automatically cancels any existing operation.\r\n   *\r\n   * @returns {AbortSignal} Signal to pass to navigator.credentials.create() or .get()\r\n   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal MDN - AbortSignal}\r\n   */\r\n  createNewAbortSignal(): AbortSignal {\r\n    // Abort any existing calls to navigator.credentials.create() or navigator.credentials.get()\r\n    if (this.controller) {\r\n      const abortError = new Error('Cancelling existing WebAuthn API call for new one')\r\n      abortError.name = 'AbortError'\r\n      this.controller.abort(abortError)\r\n    }\r\n\r\n    const newController = new AbortController()\r\n    this.controller = newController\r\n    return newController.signal\r\n  }\r\n\r\n  /**\r\n   * Manually cancel the current WebAuthn operation.\r\n   * Useful for cleaning up when user cancels or navigates away.\r\n   *\r\n   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/AbortController/abort MDN - AbortController.abort}\r\n   */\r\n  cancelCeremony(): void {\r\n    if (this.controller) {\r\n      const abortError = new Error('Manually cancelling existing WebAuthn API call')\r\n      abortError.name = 'AbortError'\r\n      this.controller.abort(abortError)\r\n      this.controller = undefined\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Singleton instance to ensure only one WebAuthn ceremony is active at a time.\r\n * This prevents \"operation already in progress\" errors when retrying WebAuthn operations.\r\n *\r\n * @experimental This instance is experimental and may change in future releases\r\n */\r\nexport const webAuthnAbortService = new WebAuthnAbortService()\r\n\r\n/**\r\n * Server response format for WebAuthn credential creation options.\r\n * Uses W3C standard JSON format with base64url-encoded binary fields.\r\n */\r\nexport type ServerCredentialCreationOptions = PublicKeyCredentialCreationOptionsJSON\r\n\r\n/**\r\n * Server response format for WebAuthn credential request options.\r\n * Uses W3C standard JSON format with base64url-encoded binary fields.\r\n */\r\nexport type ServerCredentialRequestOptions = PublicKeyCredentialRequestOptionsJSON\r\n\r\n/**\r\n * Convert base64url encoded strings in WebAuthn credential creation options to ArrayBuffers\r\n * as required by the WebAuthn browser API.\r\n * Supports both native WebAuthn Level 3 parseCreationOptionsFromJSON and manual fallback.\r\n *\r\n * @param {ServerCredentialCreationOptions} options - JSON options from server with base64url encoded fields\r\n * @returns {PublicKeyCredentialCreationOptionsFuture} Options ready for navigator.credentials.create()\r\n * @see {@link https://w3c.github.io/webauthn/#sctn-parseCreationOptionsFromJSON W3C WebAuthn Spec - parseCreationOptionsFromJSON}\r\n */\r\nexport function deserializeCredentialCreationOptions(\r\n  options: ServerCredentialCreationOptions\r\n): PublicKeyCredentialCreationOptionsFuture {\r\n  if (!options) {\r\n    throw new Error('Credential creation options are required')\r\n  }\r\n\r\n  // Check if the native parseCreationOptionsFromJSON method is available\r\n  if (\r\n    typeof PublicKeyCredential !== 'undefined' &&\r\n    'parseCreationOptionsFromJSON' in PublicKeyCredential &&\r\n    typeof (PublicKeyCredential as unknown as PublicKeyCredentialFuture)\r\n      .parseCreationOptionsFromJSON === 'function'\r\n  ) {\r\n    // Use the native WebAuthn Level 3 method\r\n    return (\r\n      PublicKeyCredential as unknown as PublicKeyCredentialFuture\r\n    ).parseCreationOptionsFromJSON(\r\n      /** we assert the options here as typescript still doesn't know about future webauthn types */\r\n      options as any\r\n    ) as PublicKeyCredentialCreationOptionsFuture\r\n  }\r\n\r\n  // Fallback to manual parsing for browsers that don't support the native method\r\n  // Destructure to separate fields that need transformation\r\n  const { challenge: challengeStr, user: userOpts, excludeCredentials, ...restOptions } = options\r\n\r\n  // Convert challenge from base64url to ArrayBuffer\r\n  const challenge = base64UrlToUint8Array(challengeStr).buffer as ArrayBuffer\r\n\r\n  // Convert user.id from base64url to ArrayBuffer\r\n  const user: PublicKeyCredentialUserEntity = {\r\n    ...userOpts,\r\n    id: base64UrlToUint8Array(userOpts.id).buffer as ArrayBuffer,\r\n  }\r\n\r\n  // Build the result object\r\n  const result: PublicKeyCredentialCreationOptionsFuture = {\r\n    ...restOptions,\r\n    challenge,\r\n    user,\r\n  }\r\n\r\n  // Only add excludeCredentials if it exists\r\n  if (excludeCredentials && excludeCredentials.length > 0) {\r\n    result.excludeCredentials = new Array(excludeCredentials.length)\r\n\r\n    for (let i = 0; i < excludeCredentials.length; i++) {\r\n      const cred = excludeCredentials[i]\r\n      result.excludeCredentials[i] = {\r\n        ...cred,\r\n        id: base64UrlToUint8Array(cred.id).buffer,\r\n        type: cred.type || 'public-key',\r\n        // Cast transports to handle future transport types like \"cable\"\r\n        transports: cred.transports,\r\n      }\r\n    }\r\n  }\r\n\r\n  return result\r\n}\r\n\r\n/**\r\n * Convert base64url encoded strings in WebAuthn credential request options to ArrayBuffers\r\n * as required by the WebAuthn browser API.\r\n * Supports both native WebAuthn Level 3 parseRequestOptionsFromJSON and manual fallback.\r\n *\r\n * @param {ServerCredentialRequestOptions} options - JSON options from server with base64url encoded fields\r\n * @returns {PublicKeyCredentialRequestOptionsFuture} Options ready for navigator.credentials.get()\r\n * @see {@link https://w3c.github.io/webauthn/#sctn-parseRequestOptionsFromJSON W3C WebAuthn Spec - parseRequestOptionsFromJSON}\r\n */\r\nexport function deserializeCredentialRequestOptions(\r\n  options: ServerCredentialRequestOptions\r\n): PublicKeyCredentialRequestOptionsFuture {\r\n  if (!options) {\r\n    throw new Error('Credential request options are required')\r\n  }\r\n\r\n  // Check if the native parseRequestOptionsFromJSON method is available\r\n  if (\r\n    typeof PublicKeyCredential !== 'undefined' &&\r\n    'parseRequestOptionsFromJSON' in PublicKeyCredential &&\r\n    typeof (PublicKeyCredential as unknown as PublicKeyCredentialFuture)\r\n      .parseRequestOptionsFromJSON === 'function'\r\n  ) {\r\n    // Use the native WebAuthn Level 3 method\r\n    return (\r\n      PublicKeyCredential as unknown as PublicKeyCredentialFuture\r\n    ).parseRequestOptionsFromJSON(options) as PublicKeyCredentialRequestOptionsFuture\r\n  }\r\n\r\n  // Fallback to manual parsing for browsers that don't support the native method\r\n  // Destructure to separate fields that need transformation\r\n  const { challenge: challengeStr, allowCredentials, ...restOptions } = options\r\n\r\n  // Convert challenge from base64url to ArrayBuffer\r\n  const challenge = base64UrlToUint8Array(challengeStr).buffer as ArrayBuffer\r\n\r\n  // Build the result object\r\n  const result: PublicKeyCredentialRequestOptionsFuture = {\r\n    ...restOptions,\r\n    challenge,\r\n  }\r\n\r\n  // Only add allowCredentials if it exists\r\n  if (allowCredentials && allowCredentials.length > 0) {\r\n    result.allowCredentials = new Array(allowCredentials.length)\r\n\r\n    for (let i = 0; i < allowCredentials.length; i++) {\r\n      const cred = allowCredentials[i]\r\n      result.allowCredentials[i] = {\r\n        ...cred,\r\n        id: base64UrlToUint8Array(cred.id).buffer,\r\n        type: cred.type || 'public-key',\r\n        // Cast transports to handle future transport types like \"cable\"\r\n        transports: cred.transports,\r\n      }\r\n    }\r\n  }\r\n\r\n  return result\r\n}\r\n\r\n/**\r\n * Server format for credential response with base64url-encoded binary fields\r\n * Can be either a registration or authentication response\r\n */\r\nexport type ServerCredentialResponse = RegistrationResponseJSON | AuthenticationResponseJSON\r\n\r\n/**\r\n * Convert a registration/enrollment credential response to server format.\r\n * Serializes binary fields to base64url for JSON transmission.\r\n * Supports both native WebAuthn Level 3 toJSON and manual fallback.\r\n *\r\n * @param {RegistrationCredential} credential - Credential from navigator.credentials.create()\r\n * @returns {RegistrationResponseJSON} JSON-serializable credential for server\r\n * @see {@link https://w3c.github.io/webauthn/#dom-publickeycredential-tojson W3C WebAuthn Spec - toJSON}\r\n */\r\nexport function serializeCredentialCreationResponse(\r\n  credential: RegistrationCredential\r\n): RegistrationResponseJSON {\r\n  // Check if the credential instance has the toJSON method\r\n  if ('toJSON' in credential && typeof credential.toJSON === 'function') {\r\n    // Use the native WebAuthn Level 3 method\r\n    return (credential as RegistrationCredential).toJSON()\r\n  }\r\n  const credentialWithAttachment = credential as PublicKeyCredential & {\r\n    response: AuthenticatorAttestationResponse\r\n    authenticatorAttachment?: string | null\r\n  }\r\n\r\n  return {\r\n    id: credential.id,\r\n    rawId: credential.id,\r\n    response: {\r\n      attestationObject: bytesToBase64URL(new Uint8Array(credential.response.attestationObject)),\r\n      clientDataJSON: bytesToBase64URL(new Uint8Array(credential.response.clientDataJSON)),\r\n    },\r\n    type: 'public-key',\r\n    clientExtensionResults: credential.getClientExtensionResults(),\r\n    // Convert null to undefined and cast to AuthenticatorAttachment type\r\n    authenticatorAttachment: (credentialWithAttachment.authenticatorAttachment ?? undefined) as\r\n      | AuthenticatorAttachment\r\n      | undefined,\r\n  }\r\n}\r\n\r\n/**\r\n * Convert an authentication/verification credential response to server format.\r\n * Serializes binary fields to base64url for JSON transmission.\r\n * Supports both native WebAuthn Level 3 toJSON and manual fallback.\r\n *\r\n * @param {AuthenticationCredential} credential - Credential from navigator.credentials.get()\r\n * @returns {AuthenticationResponseJSON} JSON-serializable credential for server\r\n * @see {@link https://w3c.github.io/webauthn/#dom-publickeycredential-tojson W3C WebAuthn Spec - toJSON}\r\n */\r\nexport function serializeCredentialRequestResponse(\r\n  credential: AuthenticationCredential\r\n): AuthenticationResponseJSON {\r\n  // Check if the credential instance has the toJSON method\r\n  if ('toJSON' in credential && typeof credential.toJSON === 'function') {\r\n    // Use the native WebAuthn Level 3 method\r\n    return (credential as AuthenticationCredential).toJSON()\r\n  }\r\n\r\n  // Fallback to manual conversion for browsers that don't support toJSON\r\n  // Access authenticatorAttachment via type assertion to handle TypeScript version differences\r\n  // @simplewebauthn/types includes this property but base TypeScript 4.7.4 doesn't\r\n  const credentialWithAttachment = credential as PublicKeyCredential & {\r\n    response: AuthenticatorAssertionResponse\r\n    authenticatorAttachment?: string | null\r\n  }\r\n\r\n  const clientExtensionResults = credential.getClientExtensionResults()\r\n  const assertionResponse = credential.response\r\n\r\n  return {\r\n    id: credential.id,\r\n    rawId: credential.id, // W3C spec expects rawId to match id for JSON format\r\n    response: {\r\n      authenticatorData: bytesToBase64URL(new Uint8Array(assertionResponse.authenticatorData)),\r\n      clientDataJSON: bytesToBase64URL(new Uint8Array(assertionResponse.clientDataJSON)),\r\n      signature: bytesToBase64URL(new Uint8Array(assertionResponse.signature)),\r\n      userHandle: assertionResponse.userHandle\r\n        ? bytesToBase64URL(new Uint8Array(assertionResponse.userHandle))\r\n        : undefined,\r\n    },\r\n    type: 'public-key',\r\n    clientExtensionResults,\r\n    // Convert null to undefined and cast to AuthenticatorAttachment type\r\n    authenticatorAttachment: (credentialWithAttachment.authenticatorAttachment ?? undefined) as\r\n      | AuthenticatorAttachment\r\n      | undefined,\r\n  }\r\n}\r\n\r\n/**\r\n * A simple test to determine if a hostname is a properly-formatted domain name.\r\n * Considers localhost valid for development environments.\r\n *\r\n * A \"valid domain\" is defined here: https://url.spec.whatwg.org/#valid-domain\r\n *\r\n * Regex sourced from here:\r\n * https://www.oreilly.com/library/view/regular-expressions-cookbook/9781449327453/ch08s15.html\r\n *\r\n * @param {string} hostname - The hostname to validate\r\n * @returns {boolean} True if valid domain or localhost\r\n * @see {@link https://url.spec.whatwg.org/#valid-domain WHATWG URL Spec - Valid Domain}\r\n */\r\nexport function isValidDomain(hostname: string): boolean {\r\n  return (\r\n    // Consider localhost valid as well since it's okay wrt Secure Contexts\r\n    hostname === 'localhost' || /^([a-z0-9]+(-[a-z0-9]+)*\\.)+[a-z]{2,}$/i.test(hostname)\r\n  )\r\n}\r\n\r\n/**\r\n * Determine if the browser is capable of WebAuthn.\r\n * Checks for necessary Web APIs: PublicKeyCredential and Credential Management.\r\n *\r\n * @returns {boolean} True if browser supports WebAuthn\r\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/PublicKeyCredential#browser_compatibility MDN - PublicKeyCredential Browser Compatibility}\r\n */\r\nfunction browserSupportsWebAuthn(): boolean {\r\n  return !!(\r\n    isBrowser() &&\r\n    'PublicKeyCredential' in window &&\r\n    window.PublicKeyCredential &&\r\n    'credentials' in navigator &&\r\n    typeof navigator?.credentials?.create === 'function' &&\r\n    typeof navigator?.credentials?.get === 'function'\r\n  )\r\n}\r\n\r\n/**\r\n * Create a WebAuthn credential using the browser's credentials API.\r\n * Wraps navigator.credentials.create() with error handling.\r\n *\r\n * @param {CredentialCreationOptions} options - Options including publicKey parameters\r\n * @returns {Promise<RequestResult<RegistrationCredential, WebAuthnError>>} Created credential or error\r\n * @see {@link https://w3c.github.io/webauthn/#sctn-createCredential W3C WebAuthn Spec - Create Credential}\r\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/CredentialsContainer/create MDN - credentials.create}\r\n */\r\nexport async function createCredential(\r\n  options: StrictOmit<CredentialCreationOptions, 'publicKey'> & {\r\n    publicKey: PublicKeyCredentialCreationOptionsFuture\r\n  }\r\n): Promise<RequestResult<RegistrationCredential, WebAuthnError>> {\r\n  try {\r\n    const response = await navigator.credentials.create(\r\n      /** we assert the type here until typescript types are updated */\r\n      options as Parameters<typeof navigator.credentials.create>[0]\r\n    )\r\n    if (!response) {\r\n      return {\r\n        data: null,\r\n        error: new WebAuthnUnknownError('Empty credential response', response),\r\n      }\r\n    }\r\n    if (!(response instanceof PublicKeyCredential)) {\r\n      return {\r\n        data: null,\r\n        error: new WebAuthnUnknownError('Browser returned unexpected credential type', response),\r\n      }\r\n    }\r\n    return { data: response as RegistrationCredential, error: null }\r\n  } catch (err) {\r\n    return {\r\n      data: null,\r\n      error: identifyRegistrationError({\r\n        error: err as Error,\r\n        options,\r\n      }),\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Get a WebAuthn credential using the browser's credentials API.\r\n * Wraps navigator.credentials.get() with error handling.\r\n *\r\n * @param {CredentialRequestOptions} options - Options including publicKey parameters\r\n * @returns {Promise<RequestResult<AuthenticationCredential, WebAuthnError>>} Retrieved credential or error\r\n * @see {@link https://w3c.github.io/webauthn/#sctn-getAssertion W3C WebAuthn Spec - Get Assertion}\r\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/CredentialsContainer/get MDN - credentials.get}\r\n */\r\nexport async function getCredential(\r\n  options: StrictOmit<CredentialRequestOptions, 'publicKey'> & {\r\n    publicKey: PublicKeyCredentialRequestOptionsFuture\r\n  }\r\n): Promise<RequestResult<AuthenticationCredential, WebAuthnError>> {\r\n  try {\r\n    const response = await navigator.credentials.get(\r\n      /** we assert the type here until typescript types are updated */\r\n      options as Parameters<typeof navigator.credentials.get>[0]\r\n    )\r\n    if (!response) {\r\n      return {\r\n        data: null,\r\n        error: new WebAuthnUnknownError('Empty credential response', response),\r\n      }\r\n    }\r\n    if (!(response instanceof PublicKeyCredential)) {\r\n      return {\r\n        data: null,\r\n        error: new WebAuthnUnknownError('Browser returned unexpected credential type', response),\r\n      }\r\n    }\r\n    return { data: response as AuthenticationCredential, error: null }\r\n  } catch (err) {\r\n    return {\r\n      data: null,\r\n      error: identifyAuthenticationError({\r\n        error: err as Error,\r\n        options,\r\n      }),\r\n    }\r\n  }\r\n}\r\n\r\nexport const DEFAULT_CREATION_OPTIONS: Partial<PublicKeyCredentialCreationOptionsFuture> = {\r\n  hints: ['security-key'],\r\n  authenticatorSelection: {\r\n    authenticatorAttachment: 'cross-platform',\r\n    requireResidentKey: false,\r\n    /** set to preferred because older yubikeys don't have PIN/Biometric */\r\n    userVerification: 'preferred',\r\n    residentKey: 'discouraged',\r\n  },\r\n  attestation: 'none',\r\n}\r\n\r\nexport const DEFAULT_REQUEST_OPTIONS: Partial<PublicKeyCredentialRequestOptionsFuture> = {\r\n  /** set to preferred because older yubikeys don't have PIN/Biometric */\r\n  userVerification: 'preferred',\r\n  hints: ['security-key'],\r\n}\r\n\r\nfunction deepMerge<T>(...sources: Partial<T>[]): T {\r\n  const isObject = (val: unknown): val is Record<string, unknown> =>\r\n    val !== null && typeof val === 'object' && !Array.isArray(val)\r\n\r\n  const isArrayBufferLike = (val: unknown): val is ArrayBuffer | ArrayBufferView =>\r\n    val instanceof ArrayBuffer || ArrayBuffer.isView(val)\r\n\r\n  const result: Partial<T> = {}\r\n\r\n  for (const source of sources) {\r\n    if (!source) continue\r\n\r\n    for (const key in source) {\r\n      const value = source[key]\r\n      if (value === undefined) continue\r\n\r\n      if (Array.isArray(value)) {\r\n        // preserve array reference, including unions like AuthenticatorTransport[]\r\n        result[key] = value as T[typeof key]\r\n      } else if (isArrayBufferLike(value)) {\r\n        result[key] = value as T[typeof key]\r\n      } else if (isObject(value)) {\r\n        const existing = result[key]\r\n        if (isObject(existing)) {\r\n          result[key] = deepMerge(existing, value) as unknown as T[typeof key]\r\n        } else {\r\n          result[key] = deepMerge(value) as unknown as T[typeof key]\r\n        }\r\n      } else {\r\n        result[key] = value as T[typeof key]\r\n      }\r\n    }\r\n  }\r\n\r\n  return result as T\r\n}\r\n\r\n/**\r\n * Merges WebAuthn credential creation options with overrides.\r\n * Sets sensible defaults for authenticator selection and extensions.\r\n *\r\n * @param {PublicKeyCredentialCreationOptionsFuture} baseOptions - The base options from the server\r\n * @param {PublicKeyCredentialCreationOptionsFuture} overrides - Optional overrides to apply\r\n * @param {string} friendlyName - Optional friendly name for the credential\r\n * @returns {PublicKeyCredentialCreationOptionsFuture} Merged credential creation options\r\n * @see {@link https://w3c.github.io/webauthn/#dictdef-authenticatorselectioncriteria W3C WebAuthn Spec - AuthenticatorSelectionCriteria}\r\n */\r\nexport function mergeCredentialCreationOptions(\r\n  baseOptions: PublicKeyCredentialCreationOptionsFuture,\r\n  overrides?: Partial<PublicKeyCredentialCreationOptionsFuture>\r\n): PublicKeyCredentialCreationOptionsFuture {\r\n  return deepMerge(DEFAULT_CREATION_OPTIONS, baseOptions, overrides || {})\r\n}\r\n\r\n/**\r\n * Merges WebAuthn credential request options with overrides.\r\n * Sets sensible defaults for user verification and hints.\r\n *\r\n * @param {PublicKeyCredentialRequestOptionsFuture} baseOptions - The base options from the server\r\n * @param {PublicKeyCredentialRequestOptionsFuture} overrides - Optional overrides to apply\r\n * @returns {PublicKeyCredentialRequestOptionsFuture} Merged credential request options\r\n * @see {@link https://w3c.github.io/webauthn/#dictdef-publickeycredentialrequestoptions W3C WebAuthn Spec - PublicKeyCredentialRequestOptions}\r\n */\r\nexport function mergeCredentialRequestOptions(\r\n  baseOptions: PublicKeyCredentialRequestOptionsFuture,\r\n  overrides?: Partial<PublicKeyCredentialRequestOptionsFuture>\r\n): PublicKeyCredentialRequestOptionsFuture {\r\n  return deepMerge(DEFAULT_REQUEST_OPTIONS, baseOptions, overrides || {})\r\n}\r\n\r\n/**\r\n * WebAuthn API wrapper for Supabase Auth.\r\n * Provides methods for enrolling, challenging, verifying, authenticating, and registering WebAuthn credentials.\r\n *\r\n * @experimental This API is experimental and may change in future releases\r\n * @see {@link https://w3c.github.io/webauthn/ W3C WebAuthn Specification}\r\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/Web_Authentication_API MDN - Web Authentication API}\r\n */\r\nexport class WebAuthnApi {\r\n  public enroll: typeof WebAuthnApi.prototype._enroll\r\n  public challenge: typeof WebAuthnApi.prototype._challenge\r\n  public verify: typeof WebAuthnApi.prototype._verify\r\n  public authenticate: typeof WebAuthnApi.prototype._authenticate\r\n  public register: typeof WebAuthnApi.prototype._register\r\n\r\n  constructor(private client: GoTrueClient) {\r\n    // Bind all methods so they can be destructured\r\n    this.enroll = this._enroll.bind(this)\r\n    this.challenge = this._challenge.bind(this)\r\n    this.verify = this._verify.bind(this)\r\n    this.authenticate = this._authenticate.bind(this)\r\n    this.register = this._register.bind(this)\r\n  }\r\n\r\n  /**\r\n   * Enroll a new WebAuthn factor.\r\n   * Creates an unverified WebAuthn factor that must be verified with a credential.\r\n   *\r\n   * @experimental This method is experimental and may change in future releases\r\n   * @param {Omit<MFAEnrollWebauthnParams, 'factorType'>} params - Enrollment parameters (friendlyName required)\r\n   * @returns {Promise<AuthMFAEnrollWebauthnResponse>} Enrolled factor details or error\r\n   * @see {@link https://w3c.github.io/webauthn/#sctn-registering-a-new-credential W3C WebAuthn Spec - Registering a New Credential}\r\n   */\r\n  public async _enroll(\r\n    params: Omit<MFAEnrollWebauthnParams, 'factorType'>\r\n  ): Promise<AuthMFAEnrollWebauthnResponse> {\r\n    return this.client.mfa.enroll({ ...params, factorType: 'webauthn' })\r\n  }\r\n\r\n  /**\r\n   * Challenge for WebAuthn credential creation or authentication.\r\n   * Combines server challenge with browser credential operations.\r\n   * Handles both registration (create) and authentication (request) flows.\r\n   *\r\n   * @experimental This method is experimental and may change in future releases\r\n   * @param {MFAChallengeWebauthnParams & { friendlyName?: string; signal?: AbortSignal }} params - Challenge parameters including factorId\r\n   * @param {Object} overrides - Allows you to override the parameters passed to navigator.credentials\r\n   * @param {PublicKeyCredentialCreationOptionsFuture} overrides.create - Override options for credential creation\r\n   * @param {PublicKeyCredentialRequestOptionsFuture} overrides.request - Override options for credential request\r\n   * @returns {Promise<RequestResult>} Challenge response with credential or error\r\n   * @see {@link https://w3c.github.io/webauthn/#sctn-credential-creation W3C WebAuthn Spec - Credential Creation}\r\n   * @see {@link https://w3c.github.io/webauthn/#sctn-verifying-assertion W3C WebAuthn Spec - Verifying Assertion}\r\n   */\r\n  public async _challenge(\r\n    {\r\n      factorId,\r\n      webauthn,\r\n      friendlyName,\r\n      signal,\r\n    }: MFAChallengeWebauthnParams & { friendlyName?: string; signal?: AbortSignal },\r\n    overrides?:\r\n      | {\r\n          create?: Partial<PublicKeyCredentialCreationOptionsFuture>\r\n          request?: never\r\n        }\r\n      | {\r\n          create?: never\r\n          request?: Partial<PublicKeyCredentialRequestOptionsFuture>\r\n        }\r\n  ): Promise<\r\n    RequestResult<\r\n      { factorId: string; challengeId: string } & {\r\n        webauthn: StrictOmit<\r\n          MFAVerifyWebauthnParamFields<'create' | 'request'>['webauthn'],\r\n          'rpId' | 'rpOrigins'\r\n        >\r\n      },\r\n      WebAuthnError | AuthError\r\n    >\r\n  > {\r\n    try {\r\n      // Get challenge from server using the client's MFA methods\r\n      const { data: challengeResponse, error: challengeError } = await this.client.mfa.challenge({\r\n        factorId,\r\n        webauthn,\r\n      })\r\n\r\n      if (!challengeResponse) {\r\n        return { data: null, error: challengeError }\r\n      }\r\n\r\n      const abortSignal = signal ?? webAuthnAbortService.createNewAbortSignal()\r\n\r\n      /** webauthn will fail if either of the name/displayname are blank */\r\n      if (challengeResponse.webauthn.type === 'create') {\r\n        const { user } = challengeResponse.webauthn.credential_options.publicKey\r\n        if (!user.name) {\r\n          user.name = `${user.id}:${friendlyName}`\r\n        }\r\n        if (!user.displayName) {\r\n          user.displayName = user.name\r\n        }\r\n      }\r\n\r\n      switch (challengeResponse.webauthn.type) {\r\n        case 'create': {\r\n          const options = mergeCredentialCreationOptions(\r\n            challengeResponse.webauthn.credential_options.publicKey,\r\n            overrides?.create\r\n          )\r\n\r\n          const { data, error } = await createCredential({\r\n            publicKey: options,\r\n            signal: abortSignal,\r\n          })\r\n\r\n          if (data) {\r\n            return {\r\n              data: {\r\n                factorId,\r\n                challengeId: challengeResponse.id,\r\n                webauthn: {\r\n                  type: challengeResponse.webauthn.type,\r\n                  credential_response: data,\r\n                },\r\n              },\r\n              error: null,\r\n            }\r\n          }\r\n          return { data: null, error }\r\n        }\r\n\r\n        case 'request': {\r\n          const options = mergeCredentialRequestOptions(\r\n            challengeResponse.webauthn.credential_options.publicKey,\r\n            overrides?.request\r\n          )\r\n\r\n          const { data, error } = await getCredential({\r\n            ...challengeResponse.webauthn.credential_options,\r\n            publicKey: options,\r\n            signal: abortSignal,\r\n          })\r\n\r\n          if (data) {\r\n            return {\r\n              data: {\r\n                factorId,\r\n                challengeId: challengeResponse.id,\r\n                webauthn: {\r\n                  type: challengeResponse.webauthn.type,\r\n                  credential_response: data,\r\n                },\r\n              },\r\n              error: null,\r\n            }\r\n          }\r\n          return { data: null, error }\r\n        }\r\n      }\r\n    } catch (error) {\r\n      if (isAuthError(error)) {\r\n        return { data: null, error }\r\n      }\r\n      return {\r\n        data: null,\r\n        error: new AuthUnknownError('Unexpected error in challenge', error),\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Verify a WebAuthn credential with the server.\r\n   * Completes the WebAuthn ceremony by sending the credential to the server for verification.\r\n   *\r\n   * @experimental This method is experimental and may change in future releases\r\n   * @param {Object} params - Verification parameters\r\n   * @param {string} params.challengeId - ID of the challenge being verified\r\n   * @param {string} params.factorId - ID of the WebAuthn factor\r\n   * @param {MFAVerifyWebauthnParams<T>['webauthn']} params.webauthn - WebAuthn credential response\r\n   * @returns {Promise<AuthMFAVerifyResponse>} Verification result with session or error\r\n   * @see {@link https://w3c.github.io/webauthn/#sctn-verifying-assertion W3C WebAuthn Spec - Verifying an Authentication Assertion}\r\n   * */\r\n  public async _verify<T extends 'create' | 'request'>({\r\n    challengeId,\r\n    factorId,\r\n    webauthn,\r\n  }: {\r\n    challengeId: string\r\n    factorId: string\r\n    webauthn: MFAVerifyWebauthnParams<T>['webauthn']\r\n  }): Promise<AuthMFAVerifyResponse> {\r\n    return this.client.mfa.verify({\r\n      factorId,\r\n      challengeId,\r\n      webauthn: webauthn,\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Complete WebAuthn authentication flow.\r\n   * Performs challenge and verification in a single operation for existing credentials.\r\n   *\r\n   * @experimental This method is experimental and may change in future releases\r\n   * @param {Object} params - Authentication parameters\r\n   * @param {string} params.factorId - ID of the WebAuthn factor to authenticate with\r\n   * @param {Object} params.webauthn - WebAuthn configuration\r\n   * @param {string} params.webauthn.rpId - Relying Party ID (defaults to current hostname)\r\n   * @param {string[]} params.webauthn.rpOrigins - Allowed origins (defaults to current origin)\r\n   * @param {AbortSignal} params.webauthn.signal - Optional abort signal\r\n   * @param {PublicKeyCredentialRequestOptionsFuture} overrides - Override options for navigator.credentials.get\r\n   * @returns {Promise<RequestResult<AuthMFAVerifyResponseData, WebAuthnError | AuthError>>} Authentication result\r\n   * @see {@link https://w3c.github.io/webauthn/#sctn-authentication W3C WebAuthn Spec - Authentication Ceremony}\r\n   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/PublicKeyCredentialRequestOptions MDN - PublicKeyCredentialRequestOptions}\r\n   */\r\n  public async _authenticate(\r\n    {\r\n      factorId,\r\n      webauthn: {\r\n        rpId = typeof window !== 'undefined' ? window.location.hostname : undefined,\r\n        rpOrigins = typeof window !== 'undefined' ? [window.location.origin] : undefined,\r\n        signal,\r\n      },\r\n    }: {\r\n      factorId: string\r\n      webauthn: {\r\n        rpId?: string\r\n        rpOrigins?: string[]\r\n        signal?: AbortSignal\r\n      }\r\n    },\r\n    overrides?: PublicKeyCredentialRequestOptionsFuture\r\n  ): Promise<RequestResult<AuthMFAVerifyResponseData, WebAuthnError | AuthError>> {\r\n    if (!rpId) {\r\n      return {\r\n        data: null,\r\n        error: new AuthError('rpId is required for WebAuthn authentication'),\r\n      }\r\n    }\r\n    try {\r\n      if (!browserSupportsWebAuthn()) {\r\n        return {\r\n          data: null,\r\n          error: new AuthUnknownError('Browser does not support WebAuthn', null),\r\n        }\r\n      }\r\n\r\n      // Get challenge and credential\r\n      const { data: challengeResponse, error: challengeError } = await this.challenge(\r\n        {\r\n          factorId,\r\n          webauthn: { rpId, rpOrigins },\r\n          signal,\r\n        },\r\n        { request: overrides }\r\n      )\r\n\r\n      if (!challengeResponse) {\r\n        return { data: null, error: challengeError }\r\n      }\r\n\r\n      const { webauthn } = challengeResponse\r\n\r\n      // Verify credential\r\n      return this._verify({\r\n        factorId,\r\n        challengeId: challengeResponse.challengeId,\r\n        webauthn: {\r\n          type: webauthn.type,\r\n          rpId,\r\n          rpOrigins,\r\n          credential_response: webauthn.credential_response,\r\n        },\r\n      })\r\n    } catch (error) {\r\n      if (isAuthError(error)) {\r\n        return { data: null, error }\r\n      }\r\n      return {\r\n        data: null,\r\n        error: new AuthUnknownError('Unexpected error in authenticate', error),\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Complete WebAuthn registration flow.\r\n   * Performs enrollment, challenge, and verification in a single operation for new credentials.\r\n   *\r\n   * @experimental This method is experimental and may change in future releases\r\n   * @param {Object} params - Registration parameters\r\n   * @param {string} params.friendlyName - User-friendly name for the credential\r\n   * @param {string} params.rpId - Relying Party ID (defaults to current hostname)\r\n   * @param {string[]} params.rpOrigins - Allowed origins (defaults to current origin)\r\n   * @param {AbortSignal} params.signal - Optional abort signal\r\n   * @param {PublicKeyCredentialCreationOptionsFuture} overrides - Override options for navigator.credentials.create\r\n   * @returns {Promise<RequestResult<AuthMFAVerifyResponseData, WebAuthnError | AuthError>>} Registration result\r\n   * @see {@link https://w3c.github.io/webauthn/#sctn-registering-a-new-credential W3C WebAuthn Spec - Registration Ceremony}\r\n   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/PublicKeyCredentialCreationOptions MDN - PublicKeyCredentialCreationOptions}\r\n   */\r\n  public async _register(\r\n    {\r\n      friendlyName,\r\n      rpId = typeof window !== 'undefined' ? window.location.hostname : undefined,\r\n      rpOrigins = typeof window !== 'undefined' ? [window.location.origin] : undefined,\r\n      signal,\r\n    }: {\r\n      friendlyName: string\r\n      rpId?: string\r\n      rpOrigins?: string[]\r\n      signal?: AbortSignal\r\n    },\r\n    overrides?: Partial<PublicKeyCredentialCreationOptionsFuture>\r\n  ): Promise<RequestResult<AuthMFAVerifyResponseData, WebAuthnError | AuthError>> {\r\n    if (!rpId) {\r\n      return {\r\n        data: null,\r\n        error: new AuthError('rpId is required for WebAuthn registration'),\r\n      }\r\n    }\r\n    try {\r\n      if (!browserSupportsWebAuthn()) {\r\n        return {\r\n          data: null,\r\n          error: new AuthUnknownError('Browser does not support WebAuthn', null),\r\n        }\r\n      }\r\n\r\n      // Enroll factor\r\n      const { data: factor, error: enrollError } = await this._enroll({\r\n        friendlyName,\r\n      })\r\n\r\n      if (!factor) {\r\n        await this.client.mfa\r\n          .listFactors()\r\n          .then((factors) =>\r\n            factors.data?.all.find(\r\n              (v) =>\r\n                v.factor_type === 'webauthn' &&\r\n                v.friendly_name === friendlyName &&\r\n                v.status !== 'unverified'\r\n            )\r\n          )\r\n          .then((factor) => (factor ? this.client.mfa.unenroll({ factorId: factor?.id }) : void 0))\r\n        return { data: null, error: enrollError }\r\n      }\r\n\r\n      // Get challenge and create credential\r\n      const { data: challengeResponse, error: challengeError } = await this._challenge(\r\n        {\r\n          factorId: factor.id,\r\n          friendlyName: factor.friendly_name,\r\n          webauthn: { rpId, rpOrigins },\r\n          signal,\r\n        },\r\n        {\r\n          create: overrides,\r\n        }\r\n      )\r\n\r\n      if (!challengeResponse) {\r\n        return { data: null, error: challengeError }\r\n      }\r\n\r\n      return this._verify({\r\n        factorId: factor.id,\r\n        challengeId: challengeResponse.challengeId,\r\n        webauthn: {\r\n          rpId,\r\n          rpOrigins,\r\n          type: challengeResponse.webauthn.type,\r\n          credential_response: challengeResponse.webauthn.credential_response,\r\n        },\r\n      })\r\n    } catch (error) {\r\n      if (isAuthError(error)) {\r\n        return { data: null, error }\r\n      }\r\n      return {\r\n        data: null,\r\n        error: new AuthUnknownError('Unexpected error in register', error),\r\n      }\r\n    }\r\n  }\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
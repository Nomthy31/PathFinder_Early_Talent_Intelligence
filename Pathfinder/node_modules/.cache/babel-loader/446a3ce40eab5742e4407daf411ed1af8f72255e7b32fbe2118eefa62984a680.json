{"ast":null,"code":"import { __awaiter } from \"tslib\";\nimport { DEFAULT_HEADERS } from './constants';\nimport { isStorageVectorsError } from './errors';\nimport { post } from './fetch';\nimport { resolveFetch } from './helpers';\n/**\r\n * API class for managing Vector Data within Vector Indexes\r\n * Provides methods for inserting, querying, listing, and deleting vector embeddings\r\n */\nexport default class VectorDataApi {\n  constructor(url, headers = {}, fetch) {\n    this.shouldThrowOnError = false;\n    this.url = url.replace(/\\/$/, '');\n    this.headers = Object.assign(Object.assign({}, DEFAULT_HEADERS), headers);\n    this.fetch = resolveFetch(fetch);\n  }\n  /**\r\n   * Enable throwing errors instead of returning them in the response\r\n   * When enabled, failed operations will throw instead of returning { data: null, error }\r\n   *\r\n   * @returns This instance for method chaining\r\n   * @example\r\n   * ```typescript\r\n   * const client = new VectorDataApi(url, headers)\r\n   * client.throwOnError()\r\n   * const { data } = await client.putVectors(options) // throws on error\r\n   * ```\r\n   */\n  throwOnError() {\n    this.shouldThrowOnError = true;\n    return this;\n  }\n  /**\r\n   * Inserts or updates vectors in batch (upsert operation)\r\n   * Accepts 1-500 vectors per request. Larger batches should be split\r\n   *\r\n   * @param options - Vector insertion options\r\n   * @param options.vectorBucketName - Name of the parent vector bucket\r\n   * @param options.indexName - Name of the target index\r\n   * @param options.vectors - Array of vectors to insert/update (1-500 items)\r\n   * @returns Promise with empty response on success or error\r\n   *\r\n   * @throws {StorageVectorsApiError} With code:\r\n   * - `S3VectorConflictException` if duplicate key conflict occurs (HTTP 409)\r\n   * - `S3VectorNotFoundException` if bucket or index doesn't exist (HTTP 404)\r\n   * - `InternalError` for server errors (HTTP 500)\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * const { data, error } = await client.putVectors({\r\n   *   vectorBucketName: 'embeddings-prod',\r\n   *   indexName: 'documents-openai-small',\r\n   *   vectors: [\r\n   *     {\r\n   *       key: 'doc-1',\r\n   *       data: { float32: [0.1, 0.2, 0.3, ...] }, // 1536 dimensions\r\n   *       metadata: { title: 'Introduction', page: 1 }\r\n   *     },\r\n   *     {\r\n   *       key: 'doc-2',\r\n   *       data: { float32: [0.4, 0.5, 0.6, ...] },\r\n   *       metadata: { title: 'Conclusion', page: 42 }\r\n   *     }\r\n   *   ]\r\n   * })\r\n   * ```\r\n   */\n  putVectors(options) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        // Validate batch size\n        if (options.vectors.length < 1 || options.vectors.length > 500) {\n          throw new Error('Vector batch size must be between 1 and 500 items');\n        }\n        const data = yield post(this.fetch, `${this.url}/PutVectors`, options, {\n          headers: this.headers\n        });\n        return {\n          data: data || {},\n          error: null\n        };\n      } catch (error) {\n        if (this.shouldThrowOnError) {\n          throw error;\n        }\n        if (isStorageVectorsError(error)) {\n          return {\n            data: null,\n            error\n          };\n        }\n        throw error;\n      }\n    });\n  }\n  /**\r\n   * Retrieves vectors by their keys in batch\r\n   * Optionally includes vector data and/or metadata in response\r\n   * Additional permissions required when returning data or metadata\r\n   *\r\n   * @param options - Vector retrieval options\r\n   * @param options.vectorBucketName - Name of the parent vector bucket\r\n   * @param options.indexName - Name of the index\r\n   * @param options.keys - Array of vector keys to retrieve\r\n   * @param options.returnData - Whether to include vector embeddings (requires permission)\r\n   * @param options.returnMetadata - Whether to include metadata (requires permission)\r\n   * @returns Promise with array of vectors or error\r\n   *\r\n   * @throws {StorageVectorsApiError} With code:\r\n   * - `S3VectorNotFoundException` if bucket or index doesn't exist (HTTP 404)\r\n   * - `InternalError` for server errors (HTTP 500)\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * const { data, error } = await client.getVectors({\r\n   *   vectorBucketName: 'embeddings-prod',\r\n   *   indexName: 'documents-openai-small',\r\n   *   keys: ['doc-1', 'doc-2', 'doc-3'],\r\n   *   returnData: false,     // Don't return embeddings\r\n   *   returnMetadata: true   // Return metadata only\r\n   * })\r\n   * if (data) {\r\n   *   data.vectors.forEach(v => console.log(v.key, v.metadata))\r\n   * }\r\n   * ```\r\n   */\n  getVectors(options) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const data = yield post(this.fetch, `${this.url}/GetVectors`, options, {\n          headers: this.headers\n        });\n        return {\n          data,\n          error: null\n        };\n      } catch (error) {\n        if (this.shouldThrowOnError) {\n          throw error;\n        }\n        if (isStorageVectorsError(error)) {\n          return {\n            data: null,\n            error\n          };\n        }\n        throw error;\n      }\n    });\n  }\n  /**\r\n   * Lists/scans vectors in an index with pagination\r\n   * Supports parallel scanning via segment configuration for high-throughput scenarios\r\n   * Additional permissions required when returning data or metadata\r\n   *\r\n   * @param options - Vector listing options\r\n   * @param options.vectorBucketName - Name of the parent vector bucket\r\n   * @param options.indexName - Name of the index\r\n   * @param options.maxResults - Maximum results per page (default: 500, max: 1000)\r\n   * @param options.nextToken - Pagination token from previous response\r\n   * @param options.returnData - Whether to include vector embeddings (requires permission)\r\n   * @param options.returnMetadata - Whether to include metadata (requires permission)\r\n   * @param options.segmentCount - Total parallel segments (1-16) for distributed scanning\r\n   * @param options.segmentIndex - Zero-based segment index (0 to segmentCount-1)\r\n   * @returns Promise with array of vectors, pagination token, or error\r\n   *\r\n   * @throws {StorageVectorsApiError} With code:\r\n   * - `S3VectorNotFoundException` if bucket or index doesn't exist (HTTP 404)\r\n   * - `InternalError` for server errors (HTTP 500)\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * // Simple pagination\r\n   * let nextToken: string | undefined\r\n   * do {\r\n   *   const { data, error } = await client.listVectors({\r\n   *     vectorBucketName: 'embeddings-prod',\r\n   *     indexName: 'documents-openai-small',\r\n   *     maxResults: 500,\r\n   *     nextToken,\r\n   *     returnMetadata: true\r\n   *   })\r\n   *   if (error) break\r\n   *   console.log('Batch:', data.vectors.length)\r\n   *   nextToken = data.nextToken\r\n   * } while (nextToken)\r\n   *\r\n   * // Parallel scanning (4 concurrent workers)\r\n   * const workers = [0, 1, 2, 3].map(async (segmentIndex) => {\r\n   *   const { data } = await client.listVectors({\r\n   *     vectorBucketName: 'embeddings-prod',\r\n   *     indexName: 'documents-openai-small',\r\n   *     segmentCount: 4,\r\n   *     segmentIndex,\r\n   *     returnMetadata: true\r\n   *   })\r\n   *   return data?.vectors || []\r\n   * })\r\n   * const results = await Promise.all(workers)\r\n   * ```\r\n   */\n  listVectors(options) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        // Validate segment configuration\n        if (options.segmentCount !== undefined) {\n          if (options.segmentCount < 1 || options.segmentCount > 16) {\n            throw new Error('segmentCount must be between 1 and 16');\n          }\n          if (options.segmentIndex !== undefined) {\n            if (options.segmentIndex < 0 || options.segmentIndex >= options.segmentCount) {\n              throw new Error(`segmentIndex must be between 0 and ${options.segmentCount - 1}`);\n            }\n          }\n        }\n        const data = yield post(this.fetch, `${this.url}/ListVectors`, options, {\n          headers: this.headers\n        });\n        return {\n          data,\n          error: null\n        };\n      } catch (error) {\n        if (this.shouldThrowOnError) {\n          throw error;\n        }\n        if (isStorageVectorsError(error)) {\n          return {\n            data: null,\n            error\n          };\n        }\n        throw error;\n      }\n    });\n  }\n  /**\r\n   * Queries for similar vectors using approximate nearest neighbor (ANN) search\r\n   * Returns top-K most similar vectors based on the configured distance metric\r\n   * Supports optional metadata filtering (requires GetVectors permission)\r\n   *\r\n   * @param options - Query options\r\n   * @param options.vectorBucketName - Name of the parent vector bucket\r\n   * @param options.indexName - Name of the index\r\n   * @param options.queryVector - Query embedding to find similar vectors\r\n   * @param options.topK - Number of nearest neighbors to return (default: 10)\r\n   * @param options.filter - Optional JSON filter for metadata (requires GetVectors permission)\r\n   * @param options.returnDistance - Whether to include similarity distances\r\n   * @param options.returnMetadata - Whether to include metadata (requires GetVectors permission)\r\n   * @returns Promise with array of similar vectors ordered by distance\r\n   *\r\n   * @throws {StorageVectorsApiError} With code:\r\n   * - `S3VectorNotFoundException` if bucket or index doesn't exist (HTTP 404)\r\n   * - `InternalError` for server errors (HTTP 500)\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * // Semantic search with filtering\r\n   * const { data, error } = await client.queryVectors({\r\n   *   vectorBucketName: 'embeddings-prod',\r\n   *   indexName: 'documents-openai-small',\r\n   *   queryVector: { float32: [0.1, 0.2, 0.3, ...] }, // 1536 dimensions\r\n   *   topK: 5,\r\n   *   filter: {\r\n   *     category: 'technical',\r\n   *     published: true\r\n   *   },\r\n   *   returnDistance: true,\r\n   *   returnMetadata: true\r\n   * })\r\n   * if (data) {\r\n   *   data.matches.forEach(match => {\r\n   *     console.log(`${match.key}: distance=${match.distance}`)\r\n   *     console.log('Metadata:', match.metadata)\r\n   *   })\r\n   * }\r\n   * ```\r\n   */\n  queryVectors(options) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const data = yield post(this.fetch, `${this.url}/QueryVectors`, options, {\n          headers: this.headers\n        });\n        return {\n          data,\n          error: null\n        };\n      } catch (error) {\n        if (this.shouldThrowOnError) {\n          throw error;\n        }\n        if (isStorageVectorsError(error)) {\n          return {\n            data: null,\n            error\n          };\n        }\n        throw error;\n      }\n    });\n  }\n  /**\r\n   * Deletes vectors by their keys in batch\r\n   * Accepts 1-500 keys per request\r\n   *\r\n   * @param options - Vector deletion options\r\n   * @param options.vectorBucketName - Name of the parent vector bucket\r\n   * @param options.indexName - Name of the index\r\n   * @param options.keys - Array of vector keys to delete (1-500 items)\r\n   * @returns Promise with empty response on success or error\r\n   *\r\n   * @throws {StorageVectorsApiError} With code:\r\n   * - `S3VectorNotFoundException` if bucket or index doesn't exist (HTTP 404)\r\n   * - `InternalError` for server errors (HTTP 500)\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * const { error } = await client.deleteVectors({\r\n   *   vectorBucketName: 'embeddings-prod',\r\n   *   indexName: 'documents-openai-small',\r\n   *   keys: ['doc-1', 'doc-2', 'doc-3']\r\n   * })\r\n   * if (!error) {\r\n   *   console.log('Vectors deleted successfully')\r\n   * }\r\n   * ```\r\n   */\n  deleteVectors(options) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        // Validate batch size\n        if (options.keys.length < 1 || options.keys.length > 500) {\n          throw new Error('Keys batch size must be between 1 and 500 items');\n        }\n        const data = yield post(this.fetch, `${this.url}/DeleteVectors`, options, {\n          headers: this.headers\n        });\n        return {\n          data: data || {},\n          error: null\n        };\n      } catch (error) {\n        if (this.shouldThrowOnError) {\n          throw error;\n        }\n        if (isStorageVectorsError(error)) {\n          return {\n            data: null,\n            error\n          };\n        }\n        throw error;\n      }\n    });\n  }\n}","map":{"version":3,"names":["DEFAULT_HEADERS","isStorageVectorsError","post","resolveFetch","VectorDataApi","constructor","url","headers","fetch","shouldThrowOnError","replace","Object","assign","throwOnError","putVectors","options","vectors","length","Error","data","error","getVectors","listVectors","segmentCount","undefined","segmentIndex","queryVectors","deleteVectors","keys"],"sources":["C:\\Users\\koketso1\\Desktop\\hubHack\\PathFinder_Early_Talent_Intelligence\\Pathfinder\\node_modules\\@supabase\\storage-js\\src\\lib\\vectors\\VectorDataApi.ts"],"sourcesContent":["import { DEFAULT_HEADERS } from './constants'\r\nimport { isStorageVectorsError } from './errors'\r\nimport { Fetch, post } from './fetch'\r\nimport { resolveFetch } from './helpers'\r\nimport {\r\n  ApiResponse,\r\n  PutVectorsOptions,\r\n  GetVectorsOptions,\r\n  GetVectorsResponse,\r\n  DeleteVectorsOptions,\r\n  ListVectorsOptions,\r\n  ListVectorsResponse,\r\n  QueryVectorsOptions,\r\n  QueryVectorsResponse,\r\n} from './types'\r\n\r\n/**\r\n * API class for managing Vector Data within Vector Indexes\r\n * Provides methods for inserting, querying, listing, and deleting vector embeddings\r\n */\r\nexport default class VectorDataApi {\r\n  protected url: string\r\n  protected headers: { [key: string]: string }\r\n  protected fetch: Fetch\r\n  protected shouldThrowOnError = false\r\n\r\n  constructor(url: string, headers: { [key: string]: string } = {}, fetch?: Fetch) {\r\n    this.url = url.replace(/\\/$/, '')\r\n    this.headers = { ...DEFAULT_HEADERS, ...headers }\r\n    this.fetch = resolveFetch(fetch)\r\n  }\r\n\r\n  /**\r\n   * Enable throwing errors instead of returning them in the response\r\n   * When enabled, failed operations will throw instead of returning { data: null, error }\r\n   *\r\n   * @returns This instance for method chaining\r\n   * @example\r\n   * ```typescript\r\n   * const client = new VectorDataApi(url, headers)\r\n   * client.throwOnError()\r\n   * const { data } = await client.putVectors(options) // throws on error\r\n   * ```\r\n   */\r\n  public throwOnError(): this {\r\n    this.shouldThrowOnError = true\r\n    return this\r\n  }\r\n\r\n  /**\r\n   * Inserts or updates vectors in batch (upsert operation)\r\n   * Accepts 1-500 vectors per request. Larger batches should be split\r\n   *\r\n   * @param options - Vector insertion options\r\n   * @param options.vectorBucketName - Name of the parent vector bucket\r\n   * @param options.indexName - Name of the target index\r\n   * @param options.vectors - Array of vectors to insert/update (1-500 items)\r\n   * @returns Promise with empty response on success or error\r\n   *\r\n   * @throws {StorageVectorsApiError} With code:\r\n   * - `S3VectorConflictException` if duplicate key conflict occurs (HTTP 409)\r\n   * - `S3VectorNotFoundException` if bucket or index doesn't exist (HTTP 404)\r\n   * - `InternalError` for server errors (HTTP 500)\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * const { data, error } = await client.putVectors({\r\n   *   vectorBucketName: 'embeddings-prod',\r\n   *   indexName: 'documents-openai-small',\r\n   *   vectors: [\r\n   *     {\r\n   *       key: 'doc-1',\r\n   *       data: { float32: [0.1, 0.2, 0.3, ...] }, // 1536 dimensions\r\n   *       metadata: { title: 'Introduction', page: 1 }\r\n   *     },\r\n   *     {\r\n   *       key: 'doc-2',\r\n   *       data: { float32: [0.4, 0.5, 0.6, ...] },\r\n   *       metadata: { title: 'Conclusion', page: 42 }\r\n   *     }\r\n   *   ]\r\n   * })\r\n   * ```\r\n   */\r\n  async putVectors(options: PutVectorsOptions): Promise<ApiResponse<undefined>> {\r\n    try {\r\n      // Validate batch size\r\n      if (options.vectors.length < 1 || options.vectors.length > 500) {\r\n        throw new Error('Vector batch size must be between 1 and 500 items')\r\n      }\r\n\r\n      const data = await post(this.fetch, `${this.url}/PutVectors`, options, {\r\n        headers: this.headers,\r\n      })\r\n      return { data: data || {}, error: null }\r\n    } catch (error) {\r\n      if (this.shouldThrowOnError) {\r\n        throw error\r\n      }\r\n      if (isStorageVectorsError(error)) {\r\n        return { data: null, error }\r\n      }\r\n      throw error\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Retrieves vectors by their keys in batch\r\n   * Optionally includes vector data and/or metadata in response\r\n   * Additional permissions required when returning data or metadata\r\n   *\r\n   * @param options - Vector retrieval options\r\n   * @param options.vectorBucketName - Name of the parent vector bucket\r\n   * @param options.indexName - Name of the index\r\n   * @param options.keys - Array of vector keys to retrieve\r\n   * @param options.returnData - Whether to include vector embeddings (requires permission)\r\n   * @param options.returnMetadata - Whether to include metadata (requires permission)\r\n   * @returns Promise with array of vectors or error\r\n   *\r\n   * @throws {StorageVectorsApiError} With code:\r\n   * - `S3VectorNotFoundException` if bucket or index doesn't exist (HTTP 404)\r\n   * - `InternalError` for server errors (HTTP 500)\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * const { data, error } = await client.getVectors({\r\n   *   vectorBucketName: 'embeddings-prod',\r\n   *   indexName: 'documents-openai-small',\r\n   *   keys: ['doc-1', 'doc-2', 'doc-3'],\r\n   *   returnData: false,     // Don't return embeddings\r\n   *   returnMetadata: true   // Return metadata only\r\n   * })\r\n   * if (data) {\r\n   *   data.vectors.forEach(v => console.log(v.key, v.metadata))\r\n   * }\r\n   * ```\r\n   */\r\n  async getVectors(options: GetVectorsOptions): Promise<ApiResponse<GetVectorsResponse>> {\r\n    try {\r\n      const data = await post(this.fetch, `${this.url}/GetVectors`, options, {\r\n        headers: this.headers,\r\n      })\r\n      return { data, error: null }\r\n    } catch (error) {\r\n      if (this.shouldThrowOnError) {\r\n        throw error\r\n      }\r\n      if (isStorageVectorsError(error)) {\r\n        return { data: null, error }\r\n      }\r\n      throw error\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Lists/scans vectors in an index with pagination\r\n   * Supports parallel scanning via segment configuration for high-throughput scenarios\r\n   * Additional permissions required when returning data or metadata\r\n   *\r\n   * @param options - Vector listing options\r\n   * @param options.vectorBucketName - Name of the parent vector bucket\r\n   * @param options.indexName - Name of the index\r\n   * @param options.maxResults - Maximum results per page (default: 500, max: 1000)\r\n   * @param options.nextToken - Pagination token from previous response\r\n   * @param options.returnData - Whether to include vector embeddings (requires permission)\r\n   * @param options.returnMetadata - Whether to include metadata (requires permission)\r\n   * @param options.segmentCount - Total parallel segments (1-16) for distributed scanning\r\n   * @param options.segmentIndex - Zero-based segment index (0 to segmentCount-1)\r\n   * @returns Promise with array of vectors, pagination token, or error\r\n   *\r\n   * @throws {StorageVectorsApiError} With code:\r\n   * - `S3VectorNotFoundException` if bucket or index doesn't exist (HTTP 404)\r\n   * - `InternalError` for server errors (HTTP 500)\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * // Simple pagination\r\n   * let nextToken: string | undefined\r\n   * do {\r\n   *   const { data, error } = await client.listVectors({\r\n   *     vectorBucketName: 'embeddings-prod',\r\n   *     indexName: 'documents-openai-small',\r\n   *     maxResults: 500,\r\n   *     nextToken,\r\n   *     returnMetadata: true\r\n   *   })\r\n   *   if (error) break\r\n   *   console.log('Batch:', data.vectors.length)\r\n   *   nextToken = data.nextToken\r\n   * } while (nextToken)\r\n   *\r\n   * // Parallel scanning (4 concurrent workers)\r\n   * const workers = [0, 1, 2, 3].map(async (segmentIndex) => {\r\n   *   const { data } = await client.listVectors({\r\n   *     vectorBucketName: 'embeddings-prod',\r\n   *     indexName: 'documents-openai-small',\r\n   *     segmentCount: 4,\r\n   *     segmentIndex,\r\n   *     returnMetadata: true\r\n   *   })\r\n   *   return data?.vectors || []\r\n   * })\r\n   * const results = await Promise.all(workers)\r\n   * ```\r\n   */\r\n  async listVectors(options: ListVectorsOptions): Promise<ApiResponse<ListVectorsResponse>> {\r\n    try {\r\n      // Validate segment configuration\r\n      if (options.segmentCount !== undefined) {\r\n        if (options.segmentCount < 1 || options.segmentCount > 16) {\r\n          throw new Error('segmentCount must be between 1 and 16')\r\n        }\r\n        if (options.segmentIndex !== undefined) {\r\n          if (options.segmentIndex < 0 || options.segmentIndex >= options.segmentCount) {\r\n            throw new Error(`segmentIndex must be between 0 and ${options.segmentCount - 1}`)\r\n          }\r\n        }\r\n      }\r\n\r\n      const data = await post(this.fetch, `${this.url}/ListVectors`, options, {\r\n        headers: this.headers,\r\n      })\r\n      return { data, error: null }\r\n    } catch (error) {\r\n      if (this.shouldThrowOnError) {\r\n        throw error\r\n      }\r\n      if (isStorageVectorsError(error)) {\r\n        return { data: null, error }\r\n      }\r\n      throw error\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Queries for similar vectors using approximate nearest neighbor (ANN) search\r\n   * Returns top-K most similar vectors based on the configured distance metric\r\n   * Supports optional metadata filtering (requires GetVectors permission)\r\n   *\r\n   * @param options - Query options\r\n   * @param options.vectorBucketName - Name of the parent vector bucket\r\n   * @param options.indexName - Name of the index\r\n   * @param options.queryVector - Query embedding to find similar vectors\r\n   * @param options.topK - Number of nearest neighbors to return (default: 10)\r\n   * @param options.filter - Optional JSON filter for metadata (requires GetVectors permission)\r\n   * @param options.returnDistance - Whether to include similarity distances\r\n   * @param options.returnMetadata - Whether to include metadata (requires GetVectors permission)\r\n   * @returns Promise with array of similar vectors ordered by distance\r\n   *\r\n   * @throws {StorageVectorsApiError} With code:\r\n   * - `S3VectorNotFoundException` if bucket or index doesn't exist (HTTP 404)\r\n   * - `InternalError` for server errors (HTTP 500)\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * // Semantic search with filtering\r\n   * const { data, error } = await client.queryVectors({\r\n   *   vectorBucketName: 'embeddings-prod',\r\n   *   indexName: 'documents-openai-small',\r\n   *   queryVector: { float32: [0.1, 0.2, 0.3, ...] }, // 1536 dimensions\r\n   *   topK: 5,\r\n   *   filter: {\r\n   *     category: 'technical',\r\n   *     published: true\r\n   *   },\r\n   *   returnDistance: true,\r\n   *   returnMetadata: true\r\n   * })\r\n   * if (data) {\r\n   *   data.matches.forEach(match => {\r\n   *     console.log(`${match.key}: distance=${match.distance}`)\r\n   *     console.log('Metadata:', match.metadata)\r\n   *   })\r\n   * }\r\n   * ```\r\n   */\r\n  async queryVectors(options: QueryVectorsOptions): Promise<ApiResponse<QueryVectorsResponse>> {\r\n    try {\r\n      const data = await post(this.fetch, `${this.url}/QueryVectors`, options, {\r\n        headers: this.headers,\r\n      })\r\n      return { data, error: null }\r\n    } catch (error) {\r\n      if (this.shouldThrowOnError) {\r\n        throw error\r\n      }\r\n      if (isStorageVectorsError(error)) {\r\n        return { data: null, error }\r\n      }\r\n      throw error\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Deletes vectors by their keys in batch\r\n   * Accepts 1-500 keys per request\r\n   *\r\n   * @param options - Vector deletion options\r\n   * @param options.vectorBucketName - Name of the parent vector bucket\r\n   * @param options.indexName - Name of the index\r\n   * @param options.keys - Array of vector keys to delete (1-500 items)\r\n   * @returns Promise with empty response on success or error\r\n   *\r\n   * @throws {StorageVectorsApiError} With code:\r\n   * - `S3VectorNotFoundException` if bucket or index doesn't exist (HTTP 404)\r\n   * - `InternalError` for server errors (HTTP 500)\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * const { error } = await client.deleteVectors({\r\n   *   vectorBucketName: 'embeddings-prod',\r\n   *   indexName: 'documents-openai-small',\r\n   *   keys: ['doc-1', 'doc-2', 'doc-3']\r\n   * })\r\n   * if (!error) {\r\n   *   console.log('Vectors deleted successfully')\r\n   * }\r\n   * ```\r\n   */\r\n  async deleteVectors(options: DeleteVectorsOptions): Promise<ApiResponse<undefined>> {\r\n    try {\r\n      // Validate batch size\r\n      if (options.keys.length < 1 || options.keys.length > 500) {\r\n        throw new Error('Keys batch size must be between 1 and 500 items')\r\n      }\r\n\r\n      const data = await post(this.fetch, `${this.url}/DeleteVectors`, options, {\r\n        headers: this.headers,\r\n      })\r\n      return { data: data || {}, error: null }\r\n    } catch (error) {\r\n      if (this.shouldThrowOnError) {\r\n        throw error\r\n      }\r\n      if (isStorageVectorsError(error)) {\r\n        return { data: null, error }\r\n      }\r\n      throw error\r\n    }\r\n  }\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}